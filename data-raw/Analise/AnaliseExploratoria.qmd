---
title: "AnaliseExploratoria"
author: "Mikael M Coletto"
format: html
editor: source
---

```{r, setup, include=FALSE}
knitr::opts_knit$set(root.dir = '/mnt/Netac-Dados/Projetos/R/steam-dashboard')
```

# An√°lise dos dados da Steam

## Objetivo

A ideia desta an√°lise √© ilustrar os conhecimentos adquiridos em R, passando pelos pontos de an√°lise explorat√≥ria, constru√ß√£o de um dashboard para visualiza√ß√£o de dados e por fim trabalhar com modelos de predi√ß√£o para alguns poss√≠veis problemas da ind√∫stria.

## Primeiro problema

Somos um est√∫dio de jogos e queremos analisar qual g√™nero/categoria de jogo tem mais sucesso na steam, mais p√∫blico e melhores avalia√ß√µes, tamb√©m queremos analisar qual faixa de pre√ßo √© mais interessante para o lan√ßamento desse novo jogo.

### Primeiro passo - An√°lise explorat√≥ria

Inicialmente iremos fazer uma an√°lise explorat√≥ria de algumas bases de dados e suas vari√°veis que podem ser interessantes para determinar sucesso de um jogo, a faixa de pre√ßo, a quantidade de vendas e relacionar essas quest√µes aos g√™neros e categorias. Foram feitas an√°lises de tr√™s bases de dados, a primeira mais completa, e as duas seguintes mais focadas em reviews de usu√°rios.

#### Base de dados - 1

A base de dados usada para esta an√°lise se encontra no Kaggle, atrav√©s deste link:

<https://www.kaggle.com/datasets/fronkongames/steam-games-dataset>

##### Skimr

Usarei o Skimr para a base de dados completa e verificarei quais dados podem ser melhor investigados.

```{r, mongoCon, echo = T, result = 'hide', message = F, warning = F, error = F}
# ## Dados de conex√£o com o banco da Steam no mongo
# mongolite::mongo_options(log_level = 1)
# mongo_db_user <- config::get("mongo_db_user", file = "config/config.yml")
# mongo_db_password <- config::get("mongo_db_password", file = "config/config.yml")
# mongo_db_url_extra <- config::get("mongo_db_url_extra", file = "config/config.yml")
# mongo_database <- config::get("mongo_database", file = "config/config.yml")
# mongo_collection <- config::get("mongo_collection_full", file = "config/config.yml")
# 
# url_srv <- paste0("mongodb+srv://", mongo_db_user, ":", mongo_db_password, mongo_db_url_extra)
# mongo_db <- mongolite::mongo(collection = mongo_collection, db = mongo_database, url = url_srv, verbose = TRUE)
# 
# ## Lendo e criando um dataframe com os dados do mongoDB
# df_full <- as.data.frame(mongo_db$find())

df_full <- data.table::fread("data-raw/steam-data/db-1/games.csv")
```

```{r, skimr}
skimr::skim(df_full)
```

```{r, cleanNames}
## Usaremos a fun√ß√£o do Janitor para editar os nomes das colunas e torn√°-las mais f√°ceis de serem manipuladas
## E ent√£o faremos a sele√ß√£o das colunas que ser√£o analisadas

df_selected <- df_full |> 
  janitor::clean_names() |>
  dplyr::select(app_id, name, developers, publishers, categories, genres, tags, release_date, estimated_owners, peak_ccu, price, windows, mac, linux, metacritic_score, user_score, positive, negative, recommendations, average_playtime_forever, median_playtime_forever, average_playtime_two_weeks, median_playtime_two_weeks) |> 
  dplyr::mutate(release_date = lubridate::mdy(release_date)) 
```

##### Removendo Softwares e n√£o jogos

Ap√≥s a an√°lise inicial, foi detectado que existiam nesta base de dados softwares que n√£o eram considerados jogos, portanto eles ser√£o exclu√≠dos para que n√£o comprometam as futuras an√°lises.

Vamos utilizar a vari√°vel `genres` para identificar os g√™neros que n√£o s√£o jogos.

```{r, genresNotGames}

# ## Colunas categories, genres, separando em linhas
# df_selected <- df_selected |>
#   tidyr::separate_rows(categories, sep = ",") |> 
#   tidyr::separate_rows(genres, sep = ",")


notGames <- c("Utilities", "Design & Illustration", "Animation & Modeling", "Game Development", "Photo Editing", "Audio Production", "Video Production", "Accounting", "Movie", "Documentary", "Episodic", "Short", "Tutorial", "360 Video")

# unique(df_selected$genres)
df_selected_gen <- df_selected |> 
  dplyr::filter(!(genres %in% notGames))

## Esses eram dois jogos que foram investigados
## Eles possu√≠am categorias Movie e Documentary tamb√©m, ent√£o esses registros foram apagados e os demais foram mantidos

# df_full_search <- df_full |> 
#   dplyr::filter(Name %in% c("Spacelords", "CAT SUDOKUüê±"))

```

##### Escolhendo as vari√°veis

Ap√≥s uma an√°lise inicial das tabelas geradas pelo `skimr`, selecionei algumas vari√°veis que seriam analisadas mais profundamente. A come√ßar pelas vari√°veis relativas a notas, cr√≠ticas e avalia√ß√µes dos jogos.

```{r, varReview}
library(ggplot2)

ggplot(df_selected_gen, aes(metacritic_score)) +
  geom_histogram() +
  theme_minimal() +
  labs(title = "Histograma da vari√°vel Metacritic Score",
       x = "Score",
       y = "Contagem")
```

Pelo Histograma podemos ver que a vari√°vel *Metacritic Score* (renomeada para metacritic_score) n√£o √© muito interessante, seu preenchimento foi visto como completo pelo skim, por√©m quase em sua totalidade as notas s√£o "0", ou seja, n√£o temos uma nota definida para avaliar os jogos.

Outras vari√°veis de avalia√ß√£o como *Reviews*, *User Score*, e *Recommendations*, foram analisadas por√©m apresentaram pouco √∫teis, ou por terem um preenchimento muito baixo ou por envolverem outros tipos de dados (que n√£o fossem uma avalia√ß√£o direta).

##### Nova m√©trica de avalia√ß√µes

A √∫nica m√©trica que parece interessante de avalia√ß√£o dos jogos, √© a de avalia√ß√µes positivas e negativas (as vari√°veis *Positive* e *Negative*).

Para isso foi criado uma nova vari√°vel, que mede a taxa de avalia√ß√µes positivas e negativas de um jogo, chamada *overall_rate*.

```{r, var_overallRate}
df_selected_gen$overall <- df_selected_gen$positive*100/(df_selected_gen$positive + df_selected_gen$negative)

df_selected_gen$overall[1:100]
```

Analisando essa nova m√©trica, verificamos que possu√≠mos dados `NaN` e valores de 100, respectivamente, resultados de de divis√µes $0/0$ e de jogos sem avalia√ß√£o negativa. Os n√∫meros NaN ser√£o removidos, j√° que n√£o ser√£o √∫teis para avalia√ß√£o dos jogos, os n√∫meros 100 ser√£o investigados mais a fundo.

##### Filtrando dados inv√°lidos

```{r, NaN-100}

## Criando uma vari√°vel do tipo fator para n√∫mero de donos estimados
levels_owners <- c("0 - 0", "0 - 20000", "20000 - 50000", "50000 - 100000", 
                   "100000 - 200000", "200000 - 500000", "500000 - 1000000",
                   "1000000 - 2000000", "2000000 - 5000000", "5000000 - 10000000", 
                   "10000000 - 20000000", "20000000 - 50000000", "50000000 - 100000000",
                   "100000000 - 200000000")

df_selected_gen$estimated_owners <- as.factor(df_selected_gen$estimated_owners)
df_selected_gen$estimated_owners <- factor(df_selected_gen$estimated_owners, levels = levels_owners)

## Verificando dados que ser√£o considerados inv√°lidos
df_100 <- df_selected_gen |> 
  dplyr::filter(positive < 20 & (overall == 100)) |> 
  dplyr::select(name, publishers, categories, genres, release_date, estimated_owners, positive, negative, overall)

## Filtrando regras
df_selected_gen <- df_selected_gen |> 
dplyr::filter(positive > 20 & 
                  ((as.integer(estimated_owners) > 2 & price > 0) | 
                     (as.integer(estimated_owners) > 3 & price == 0)) &
                overall < 100)

# skimr::skim(df_selected_gen)
```

E ent√£o defini mais alguns filtros, de jogos que possivelmente seriam problem√°ticos. Estabeleci as regras:

1.  O jogo precisa ter pelo menos 20 avalia√ß√µes positivas.

2.  O jogo precisa ter pelo menos uma avalia√ß√£o negativa (para que a avalia√ß√£o n√£o seja de 100%).

3.  O jogo precisa ter pelo menos 50 mil usu√°rios no caso de ser gratuito, e pelo menos 20 mil usu√°rios para jogos pagos.

##### Deduplica√ß√£o

Ap√≥s a an√°lise do novo banco de dados filtrado, descobri mais um problema que precisava ser tratado, dados duplicados. Verificando pelo nome dos jogos, encontrei dados duplicados, mas que possu√≠am IDs diferentes, avalia√ß√µes e √†s vezes pre√ßos diferentes. Investigando mais pelo pr√≥prio site da Steam e pelo site SteamDB ([SteamDB](https://steamdb.info)), conclu√≠ que se tratavam de dados referentes √† novas vers√µes (jogo do ano, vers√£o de luxo, etc), jogos que possu√≠am vers√µes diferentes (no caso dos Call of Dutys, vers√µes para o jogo campanha e para o jogo multiplayer, mini-expans√µes, pacotes de skins (apar√™ncias para armas e personagens), pacotes de itens pagos como benef√≠cios no jogos, etc. Portanto, decidi remover essas duplicatas, e usarei como base dados de n√∫mero de usu√°rios (o jogo base muito provavelmente vai ter mais usu√°rios) e n√∫mero de jogadores.

```{r, dedup}
library(janitor)
df_dupli <- df_selected_gen |> 
  janitor::get_dupes(name, developers)

df_selected_gen <- df_selected_gen |> 
  dplyr::arrange(name, desc(as.integer(estimated_owners)), desc(overall)) |> 
  dplyr::distinct(name, .keep_all = T)

```

Ent√£o a regra criada para este filtro respeitar√°, primeiro o n√∫mero de jogadores, o jogo que possuir mais jogadores permanecer√° na base, segundo, em caso de empate do primeiro, o jogo com melhor avalia√ß√£o.

#### Base de dados - 2

Como os dados de avalia√ß√µes eram escassas e eu j√° havia encontrado outras bases de dados, decidi analisar outras bases e verificar se possu√≠a outra que fosse mais interessante com prop√≥sito de verificar dados de avalia√ß√£o dos jogos.

```{r, db-4}
df_reviews <- data.table::fread("data-raw/steam-data/db-4/dataset.csv")

name <- unique(df_reviews$app_name)

unique(df_reviews$review_score)

df_reviews$positive <- dplyr::if_else(df_reviews$review_score == 1, 1, 0)
df_reviews$negative <- dplyr::if_else(df_reviews$review_score == -1, 1, 0)

df_reviews_group <- df_reviews |> 
  dplyr::group_by(app_id) |> 
  dplyr::summarise(count_positive = sum(positive),
                   count_negative = sum(negative)) |> 
  dplyr::distinct(app_id, .keep_all = T) |> 
  dplyr::ungroup() |> 
  dplyr::inner_join(df_reviews[!duplicated(df_reviews[, c("app_id", "app_name")]), c("app_id", "app_name")])
  
  
df_reviews_head <- df_reviews |> 
  dplyr::slice_sample(prop = 0.1)

db_unique <- df_reviews[!duplicated(df_reviews[, c("app_id", "app_name")]), c("app_id", "app_name")]


# df_reviews <- data.table::fread("data-raw/steam-data/db-5/GamesAndRecommendation/recommendations.csv")
```

Ap√≥s uma investiga√ß√£o da base, verifiquei que ela era um pouco antiga, por n√£o possuir t√≠tulos como o "Counter-Strike: Global Offensive", portanto deixei ela de lado e parti para a an√°lise da outra base de recomenda√ß√µes.

#### Base de dados - 3

```{r, db-5}
df_reviews <- data.table::fread("data-raw/steam-data/db-3/recommendations.csv")
df_games <- data.table::fread("data-raw/steam-data/db-3/games.csv")

df_games <- df_games |> 
  dplyr::filter(positive_ratio < 100 & user_reviews > 20)
```

Ap√≥s a an√°lise desta nova base de dados, conclu√≠ que ela possui sim dados mais atualizados de jogos (com jogos datados de fev/2023), mas possui menos dados relacionados a l√≠nguas suportadas (tanto legendas quanto √°udios), dados de pico de usu√°rios, dados de DLC, dados de empresas (como sites, e-mail de suporte, imagem do jogo), dados do Metacritic (por mais que n√£o tenham sido √∫teis) e dados de tempo de jogo. Ent√£o utilizarei ela apenas para verificar a avalia√ß√£o dos usu√°rios (atrav√©s das colunas `positive_ratio` e `user_reviews`). Ser√£o aplicados filtros an√°logos, n√£o podemos ter apenas avalia√ß√µes positivas (`positive_ratio == 100`) e para reviews precisamos ter pelo menos 20 (`user_reviews > 20`).

##### Deduplica√ß√£o

O mesmo processo de deduplica√ß√£o precisou ser feito na nova base.

```{r, dedup}
library(janitor)
df_dupli <- df_games |> 
  janitor::get_dupes(title)
```

Por√©m, ao contr√°rio da base anterior, neste caso todos os jogos "duplicados" se tratavam de jogos diferentes que possu√≠am o mesmo nome, portanto nenhum deles foi removido.

#### Diferen√ßas entre base 1 e 3

```{r, compareDBs, eval=FALSE}

## Antijoins atrav√©s do ID
games_antijoin_games_app_id <- dplyr::anti_join(df_games[, c("app_id", "title", "user_reviews", "date_release")], df_selected_gen[, c("app_id", "name")],
                                                by = "app_id")

# ## Antijoin ap√≥s remover os IDs n√£o encontrados, utilizando o nome dos jogos
# games_antijoin_games_name <- dplyr::anti_join(df_games[, c("app_id", "title", "user_reviews", "date_release")], df_selected_gen[, c("app_id", "name")], by = c("title" = "name"))
# 
# ## Verificando os jogos que foram exclu√≠dos pelo ID mas possu√≠am nomes iguais
# games_antijoin_games <- dplyr::anti_join(games_antijoin_games_app_id, games_antijoin_games_name)

games_antijoin_sel_app_id <- dplyr::anti_join(df_selected_gen[, c("app_id", "name", "positive", "release_date")], df_games[, c("app_id", "title")],
                                                by = "app_id")
# 
# games_antijoin_sel_name <- dplyr::anti_join(games_antijoin_sel_app_id, df_games[, c("app_id", "title")], by = c("name" = "title"))
# 
# ## Verificando os jogos que foram exclu√≠dos pelo ID mas possu√≠am nomes iguais
# games_antijoin_sel <- dplyr::anti_join(games_antijoin_sel_app_id, games_antijoin_sel_name)

df_games <- df_games |> 
  dplyr::rename(name = title)

games_fulljoin <- dplyr::full_join(df_games[, c("app_id", "name", "user_reviews", "date_release")], df_selected_gen[, c("app_id", "name", "release_date")], by = "app_id")

games_fulljoin <- dplyr::full_join(df_games, df_selected_gen, by = "app_id") |> 
  dplyr::select(app_id, name_games = name.x, rating, positive_ratio, user_reviews, 
                name_sel = name.y, overall, positive, negative, recommendations,
                date_release, release_date)

games_fulljoin_date <- games_fulljoin |> 
  dplyr::filter(release_date != date_release)

# search_in_1 <- df_games[stringr::str_detect(df_games$name, "Rainbow Six"),]
# search_in_2 <- df_selected_gen[stringr::str_detect(df_selected_gen$name, "Rainbow Six"),]

```

Usei o `anti_join` como m√©todo para avaliar os jogos que est√°vam apenas em uma das bases e n√£o na outra. Ao verificar os resultados, percebi que a base 1 exclu√≠u muitos jogos devido aos filtros aplicados, principalmente os filtros relacionados a avalia√ß√µes positivas, e os mesmos jogos na base 3 apresentavam um n√∫mero de reviews positivos maior, portanto, utilizarei a base 3 e farei a adi√ß√£o dos jogos da base 1 que n√£o est√£o presentes na base 3 para criar um √∫nico banco de dados de jogos. Para um primeiro momento onde farei a avalia√ß√£o de recomenda√ß√µes, trabalharei dessa forma, posteriormente junto √† base 3 de recomenda√ß√£o existe uma outra base com informa√ß√µes dos jogos e ser√° posteriormente agregada para adicionar informa√ß√µes.

#### Unindo as bases

```{r, joinDBs}

## Jogos presentes na base 1 que n√£o est√£o na base 3
df_antijoin_games <- dplyr::anti_join(df_selected_gen, df_games, by = "app_id") |> 
  dplyr::mutate(rating = 0, price_final = 0, price_original = 0, discount = 0, steam_deck = F, 
                db1 = T) |> 
  dplyr::select(app_id, name, date_release = release_date, win = windows, mac, linux, rating,
                positive_ratio = overall, user_reviews = user_score, price_final = price, price_original,
                discount, steam_deck, db1) 

df_games <- df_games |> 
  dplyr::mutate(db1 = F, date_release = lubridate::ymd(date_release))

df_all_games <- rbind(df_games, df_antijoin_games)

df_dupli <- df_all_games |> 
  janitor::get_dupes(name)
```

Tamb√©m foi analisado novamente as duplicatas que foram geradas, e novamente foi decidido mant√™-l√°s, j√° que representavam, ou jogos que possu√≠am o mesmo nome, mas s√£o jogos diferentes, ou s√£o diferentes vers√µes dos jogos (vers√£o normal e vers√£o game of the year ou um relan√ß√°mento por exemplo).

##### Adicionando informa√ß√µes

Agora adicionaremos √† base agrupada os dados referentes √†s informa√ß√µes do jogo, inicialmente adicionando atrav√©s de outro arquivo presente nos arquivos da base 3.

```{r, addingInfo}
run_join <- F
if(run_join){
  library(jsonlite)
  out <- lapply(readLines("data-raw/steam-data/db-3/games_metadata.json"), fromJSON)
  
  ## Unindo o terceiro elemento da lista
  for(i in 1:length(out)){
    purrr::pluck(out, i, 3)<-paste0(purrr::pluck(out, i, 3), collapse = ",")
  }
  
  ## Transformando em um dataframe para unir √† outra base
  df_metadata <- do.call(rbind.data.frame, out)
  
  ## Adicionando coluna de tags do df_metadata, e adicionando colunas de categoria, genero e tags extra do df anterior
  df_all_games <- dplyr::left_join(df_all_games, df_metadata, by = "app_id") |> 
    dplyr::select(-description) |> 
    dplyr::left_join(df_selected |> 
                       dplyr::select(app_id, categories, genres, tags) |> 
                       dplyr::rename(tags_extra = tags),
                     by = "app_id")

  ## Escrevendo nova base para n√£o precisar rodar os joins e compara√ß√µes todas as vezes
  if(!dir.exists("data-raw/steam-data/db-created")){
    dir.create("data-raw/steam-data/db-created")
  }
  data.table::fwrite(df_all_games, "data-raw/steam-data/db-created/db-reviews-join.csv")
  
}else{
  df_all_games <- data.table::fread("data-raw/steam-data/db-created/db-reviews-join.csv")
}

## Substituindo c√©lulas em branco por NA no caso de estar lendo o csv
if(!run_join){
  df_all_games <- df_all_games |> 
    dplyr::mutate(categories = ifelse(categories == "", NA, categories),
                  genres = ifelse(genres == "", NA, genres),
                  tags = ifelse(tags == "", NA, tags),
                  tags_extra = ifelse(tags_extra == "", NA, tags_extra))
}

## Verificando quantos jogos n√£o possuem categorias, g√™neros ou tags/tags_extra definidos
nrow(df_all_games[is.na(categories), ])
nrow(df_all_games[is.na(genres), ])
nrow(df_all_games[is.na(tags) & is.na(tags_extra), ])
```

### Analisando dados dos jogos

Agora que j√° uni as duas bases, e tenho uma quantidade mais razo√°vel de jogos a serem analisados, precisarei definir qual ser√° a forma de avaliar os estilos/g√™neros/categorias dos jogos, por ser uma coluna presente em ambas as bases, a vari√°vel `tags` e √© uma √≥tima candidata, por√©m ela apresenta um n√∫mero de possibilidades bastante grande e distinta, o que poderia ser prejudicial √† an√°lise. J√° as outras vari√°veis `categories` e `genres` que s√£o mais espec√≠ficas, n√£o est√£o presentes em aproximadamente 20% da base de dados. A an√°lise ser√° feita inialmente nas tr√™s para posterior decis√£o de qual ou quais usar.

```{r, tags}
## Verificando as diferen√ßas entre tags de um df e do outro (tags e tags_extra)
df_tags <- dplyr::select(df_all_games, 
                         app_id, name, tags, tags_extra)
df_tags_equal <- df_tags[tags == tags_extra,]
df_tags_not_equal <- df_tags[tags != tags_extra,]

# nrow(df_tags[is.na(tags_extra), ])
# nrow(df_tags[is.na(tags), ])

## Primeiro check ser√° em jogos que possuem n√∫meros de tags diferentes
tags_dif_ids <- df_tags_not_equal |> 
  dplyr::select(app_id, tags, tags_extra) |> 
  dplyr::mutate(check_lenght = ifelse(stringr::str_length(tags) == stringr::str_length(tags_extra), T, F))

## Separamos os que possuem apenas tamanhos diferentes de tags, a ideia inicial √© analisar o que temos de diferente, e se for apenas uma ou outra tag a mais, utilizar a combina√ß√£o destas tags
df_tags_not_equal_check <- tags_dif_ids[check_lenght == F]

## Os que tem mesmo tamanho mas n√£o tem mesmas tags, provavelmente s√£o elementos em ordens diferentes, ent√£o checarei isso
df_tags_not_equal_check_t <- tags_dif_ids[check_lenght == T]

```

#### Analisando tags de diferentes tamanhos

```{r, tags-diff-size}
vector_tags <- df_tags_not_equal_check$tags |> 
  purrr::map(\(x) stringr::str_sort(stringr::str_split_1(x, pattern = ",")))

vector_tags_ex <- df_tags_not_equal_check$tags_extra |> 
  purrr::map(\(x) stringr::str_sort(stringr::str_split_1(x, pattern = ",")))

vector_tags_aux <- vector_tags[1:5]
vector_tags_ex_aux <- vector_tags_ex[1:5]

# ## M√©todo de compara√ß√£o de strings
# cmp <- NULL
# for(i in 1:length(vector_tags_aux)){
#   cmp[[i]] <- ifelse(
#     (waldo::compare(vector_tags_aux[[i]], vector_tags_ex_aux[[i]])) == F, T, NA)
# }

## Fun√ß√£o para comparar strings por tamanho
cmp_size <- function(x, y){
  if(length(x) == length(y)){
    return(T)
  }else{
    return(F)
  }
}

## Comparando tamanhos e criando vetor com flag de tamanhos iguais ou n√£o
diff_sizes <- mapply(cmp_size, vector_tags, vector_tags_ex)
list_with_both <- NULL
for(i in 1:length(diff_sizes)){
  if(!diff_sizes[i]){
    pluck(list_with_both, i, 1) <- vector_tags_aux[i]
    pluck(list_with_both, i, 2) <- vector_tags_ex_aux[i]
    pluck(list_with_both, i, 3) <- df_tags_not_equal[[1]][[i]]
  }else{
  pluck(list_with_both, i) <- NULL
  }
}

## Analisando tags com diferentes tamanhos
list_with_both_notNull <- list_with_both
list_with_both_notNull[sapply(list_with_both_notNull, is.null)] <- NULL

## Criando uma lista com todas as tags q est√£o presentes em uma coluna e n√£o na outra 
## (est√£o em tags e n√£o est√£o em tags_extra, est√£o em tags_extra e n√£o est√£o em tags)
diff_elem <- NULL
for(i in 1:length(list_with_both_notNull)){
  elem_1 <- pluck(list_with_both_notNull, i, 1, 1)
  elem_2 <- pluck(list_with_both_notNull, i, 2, 1)
  
  diff1 <- setdiff(elem_1, elem_2)
  diff2 <- setdiff(elem_2, elem_1)
  
  pluck(diff_elem, i, 1) <- c("1", diff1, "2", diff2)
  pluck(diff_elem, i, 2) <-pluck(list_with_both_notNull, i, 3)
}



## M√©todo de compara√ß√£o de strings
# stringdist::stringdist(vector_tags_aux[[4]], vector_tags_ex_aux[[4]])

```


#### Analisando tags diferentes mas mesmo tamanho