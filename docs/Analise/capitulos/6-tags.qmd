```{r, header-tags}
########################################################################################## #
#'  Parte do arquivo de análise exploratória
#'  Arquivo focado em analisar as variáveis de tags da base unida
#' 
#'  Autor: Mikael Marin Coletto
#'  Data: 12/03/23
########################################################################################## #

## 0.1 - Bibliotecas e scripts fontes----
library(purrr)
library(dplyr)
source(here::here("R/fct-auxiliares/fct_order_strings.R"))
source(here::here("R/fct-auxiliares/fct_ajustando_tags.R"))
source(here::here("R/fct-auxiliares/fct_filter_not_games.R"))
```

```{r, tags}
teste_interno <- T
if(teste_interno){
df_all_games <- data.table::fread(here::here("data-raw/created-tables/db-reviews-join.csv")) |> 
    dplyr::mutate(tags = ifelse(tags == "", NA, tags),
                  categories = ifelse(categories == "", NA, categories),
                  genres = ifelse(genres == "", NA, genres),
                  tags_extra = ifelse(tags_extra == "", NA, tags_extra))
}

## Verificando as diferenças entre tags de um df e do outro (tags e tags_extra)
df_tags <- dplyr::select(df_all_games, 
                         app_id, title, tags, tags_extra)
df_tags_equal <- df_tags[tags == tags_extra,]
df_tags_not_equal <- df_tags[tags != tags_extra,]

# df_tags_equal_ <- df_tags_equal
# df_tags_not_equal_ <- df_tags_not_equal

# nrow(df_tags[is.na(tags_extra), ])
# nrow(df_tags[is.na(tags), ])

## Primeiro check será em jogos que possuem números de tags diferentes
tags_dif_ids <- df_tags_not_equal |> 
  dplyr::select(app_id, tags, tags_extra) |> 
  dplyr::mutate(check_lenght = ifelse(stringr::str_length(tags) == stringr::str_length(tags_extra), T, F))

```

##### Analisando tags diferentes

```{r, tags-all}
### XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX ####
### ALTERAR TAGS ALL, usar tidyr e dplyr (consultar fct_ajustando_tags)
### não é possível de forma tão simples, talvez usando trible? (lista dentro do df)
### Gerar uma lista com os elementos e fazer um "union" entre elas e um "intersect"
### XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX ####

vector_tags <- df_tags_not_equal$tags |> 
  purrr::map(\(x) stringr::str_sort(stringr::str_split_1(x, pattern = ",")))

vector_tags_ex <- df_tags_not_equal$tags_extra |> 
  purrr::map(\(x) stringr::str_sort(stringr::str_split_1(x, pattern = ",")))

# vector_tags_aux <- vector_tags[1:5]
# vector_tags_ex_aux <- vector_tags_ex[1:5]

## Criando uma lista com todas as tags q estão presentes em uma coluna e não na outra 
## (estão em tags e não estão em tags_extra, estão em tags_extra e não estão em tags)
diff_elem <- NULL
for(i in 1:length(vector_tags)){
  elem_1 <- pluck(vector_tags, i)
  elem_2 <- pluck(vector_tags_ex, i)
  
  diff1 <- setdiff(elem_1, elem_2)
  diff2 <- setdiff(elem_2, elem_1)
  equal <- intersect(elem_1, elem_2)
  
  pluck(diff_elem, i, 1) <- paste0(equal, collapse = ",")
  pluck(diff_elem, i, 2) <- paste0("1 - ", paste0(diff1, collapse = ","), ". 2 - ", paste0(diff2, collapse = ","))
  pluck(diff_elem, i, 3) <- pluck(df_tags_not_equal, 1, i)
}

## Alterando para DF, para melhor visualização
df_diff <- data.frame(t(sapply(diff_elem, c)))
colnames(df_diff) <- c("equal", "diff", "id")

df_diff <- df_diff |> 
  tidyr::separate_wider_delim(diff, ". 2", names = c("first", "seccond")) |> 
  dplyr::mutate(seccond = paste0("2", seccond)) |> 
  dplyr::mutate(equal = as.character(equal),
                id = as.integer(id))

## Investigando tags com mesmo tamanho, buscando pequenas alterações na escrita
df_diff_ <- df_diff |> 
  dplyr::filter(!(first == "1 - ") & !(seccond == "2 - ")) |> 
  dplyr::filter(stringr::str_length(first) == stringr::str_length(seccond))

## Palavras com grafias levemente diferentes serão alteradas
## Roguelike e Roguelite para Rogue-like e Rogue-lite,
## Base Building para Base-Building
## e-sports para eSports
## Football (Soccer) para Soccer
## Football (American) para Football
## Puzzle Platformer para Puzzle-Platformer

df_diff <- func_ajustando_tags(df_diff, debug)


df_diff <- df_diff |> 
  dplyr::select(id, tags)
```

##### Visualzando tags mais frequentes

Após a organização e certa limpeza das tags, vou começar com uma visualização simples para identificar as tags mais utilizadas (e as menos utilizadas). Esse processo poderá ser feito no futuro para as outras variáveis de categoria e gênero, de forma similar, já que a estrutura das variáveis é a mesma.

```{r, count-tags}
all_ordered <- df_diff$tags |> 
  purrr::map(\(x) stringr::str_sort(stringr::str_split_1(x, pattern = ",")))

## Colocando tudo numa única lista para contagem
all_string_listwise <- tolower(unlist(lapply(all_ordered, unique)))

## Fazendo a contagem e transformando em um dataframe, podemos verifiicar diretamente na tabela
df_tags_count <- as.data.frame(table(all_string_listwise), stringsAsFactors = F)
## Renomeando colunas
names(df_tags_count) <- c("tag", "count")

data.table::fwrite(df_tags_count, here::here("data-raw/created-tables/df-tags-count.csv"))

## Utilllizamos as 50 tags que mais aparecem e criamos uma nova tabela para visualização
df_tags_count |> 
  dplyr::arrange(desc(count)) |> 
  dplyr::slice_head(n = 50) |> 
  DT::datatable()
```

```{r, df-newTags}
# df_tags_not_equal$tags_all <- df_diff$tags
# df_tags_equal$tags_all <- df_tags_equal$tags

df_diff <- dplyr::rename(df_diff, tags_all = tags, app_id = id)

df_tags_equal <- dplyr::rename(df_tags_equal, tags_all = tags) |> 
  dplyr::select(-tags_extra)
df_tags_not_equal <- dplyr::inner_join(df_tags_not_equal, df_diff, by = "app_id") |> 
  dplyr::select(-tags, -tags_extra)

df_all_games_newtags <- rbind(df_tags_equal, df_tags_not_equal) |> 
  dplyr::select(app_id, tags_all)

df_all_games_newtags <- dplyr::inner_join(df_all_games, df_all_games_newtags, by="app_id") |> 
  dplyr::select(-tags, -tags_extra)

## Adicionando jogos que tinham tags ou tags_extra NA, e não foram comparados
df_all_games_na <- df_all_games |> 
  dplyr::filter(is.na(tags) | is.na(tags_extra)) |> 
  dplyr::mutate(tags_all = ifelse(is.na(tags), tags_extra, tags)) |> 
  dplyr::select(-tags, -tags_extra)

df_all_games <- rbind(df_all_games_newtags, df_all_games_na)

```

```{r, filter-notGames}
## Categorias consideradas não jogos
notGames <- c("360 Video", "Accounting", "Animation & Modeling", "Audio Production", "Design & Illustration", "Documentary", "Episodic", "Game Development", "Movie", "Photo Editing", "Short", "Software", "Software Training", "Tutorial", "Utilities", "Video Production", "Web Publishing")
notGames_genres <- paste0(notGames, collapse = "|")

## dataframe filtrando generos e tags que não são considerados jogos
df_all_games_split <- df_all_games |> 
  dplyr::filter(is.na(genres) | !stringr::str_detect(genres, notGames_genres)) |> 
  tidyr::separate_longer_delim(tags_all, delim = ",") |>  
  dplyr::rowwise() |> 
  dplyr::mutate(tags_all = func_filter_not_games_line(tags_all, notGames)) |> 
  dplyr::filter(tags_all != "notGame")

data.table::fwrite(df_all_games_split, here::here("data-raw/created-tables/db-all-games-tags-all-split.csv"))

df_all_games_filt <- df_all_games_split |> 
  dplyr::group_by(app_id) |> 
  dplyr::mutate(tags_all_ = paste0(tags_all, collapse = ",")) |> 
  dplyr::distinct(app_id, .keep_all = T) |> 
  dplyr::select(-tags_all) |> 
  dplyr::rename(tags_all = tags_all_)

data.table::fwrite(df_all_games_filt, here::here("data-raw/created-tables/db-all-games-tags-all.csv"))
```