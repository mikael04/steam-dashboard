```{r, header}
########################################################################################## #
#'  Parte do arquivo de an√°lise explorat√≥ria
#'  Arquivo focado na an√°lise da primeira base
#' 
#'  Autor: Mikael Marin Coletto
#'  Data: 11/03/23
########################################################################################## #

## 0.1 - Bibliotecas e scripts fontes----
library(ggplot2)
# library(janitor)
```


A base de dados usada para esta an√°lise se encontra no Kaggle, atrav√©s deste link:
  
  <https://www.kaggle.com/datasets/fronkongames/steam-games-dataset>
  
  ##### Skimr
  
  Usarei o Skimr para a base de dados completa e verificarei quais dados podem ser melhor investigados.

```{r, mongoCon, echo = T, result = 'hide', message = F, warning = F, error = F}
# ## Dados de conex√£o com o banco da Steam no mongo
# mongolite::mongo_options(log_level = 1)
# mongo_db_user <- config::get("mongo_db_user", file = "config/config.yml")
# mongo_db_password <- config::get("mongo_db_password", file = "config/config.yml")
# mongo_db_url_extra <- config::get("mongo_db_url_extra", file = "config/config.yml")
# mongo_database <- config::get("mongo_database", file = "config/config.yml")
# mongo_collection <- config::get("mongo_collection_full", file = "config/config.yml")
# 
# url_srv <- paste0("mongodb+srv://", mongo_db_user, ":", mongo_db_password, mongo_db_url_extra)
# mongo_db <- mongolite::mongo(collection = mongo_collection, db = mongo_database, url = url_srv, verbose = TRUE)
# 
# ## Lendo e criando um dataframe com os dados do mongoDB
# df_full <- as.data.frame(mongo_db$find())

df_full <- data.table::fread("data-raw/steam-data/db-1/games.csv")
```

```{r, skimr}
skimr::skim(df_full)
```

```{r, cleanNames}
## Usaremos a fun√ß√£o do Janitor para editar os nomes das colunas e torn√°-las mais f√°ceis de serem manipuladas
## E ent√£o faremos a sele√ß√£o das colunas que ser√£o analisadas

df_selected <- df_full |> 
  janitor::clean_names() |>
  dplyr::select(app_id, name, developers, publishers, categories, genres, tags, release_date, estimated_owners, peak_ccu, price, windows, mac, linux, metacritic_score, user_score, positive, negative, recommendations, average_playtime_forever, median_playtime_forever, average_playtime_two_weeks, median_playtime_two_weeks) |> 
  dplyr::mutate(release_date = lubridate::mdy(release_date)) 
```

##### Removendo Softwares e n√£o jogos

Ap√≥s a an√°lise inicial, foi detectado que existiam nesta base de dados softwares que n√£o eram considerados jogos, portanto eles ser√£o exclu√≠dos para que n√£o comprometam as futuras an√°lises.

Vamos utilizar a vari√°vel `genres` para identificar os g√™neros que n√£o s√£o jogos.

```{r, genresNotGames}

# ## Colunas categories, genres, separando em linhas
# df_selected <- df_selected |>
#   tidyr::separate_rows(categories, sep = ",") |> 
#   tidyr::separate_rows(genres, sep = ",")


notGames <- c("Utilities", "Design & Illustration", "Animation & Modeling", "Game Development", "Photo Editing", "Audio Production", "Video Production", "Accounting", "Movie", "Documentary", "Episodic", "Short", "Tutorial", "360 Video")

# unique(df_selected$genres)
df_selected_gen <- df_selected |> 
  dplyr::filter(!(genres %in% notGames))

## Esses eram dois jogos que foram investigados
## Eles possu√≠am categorias Movie e Documentary tamb√©m, ent√£o esses registros foram apagados e os demais foram mantidos

# df_full_search <- df_full |> 
#   dplyr::filter(Name %in% c("Spacelords", "CAT SUDOKUüê±"))

```

##### Escolhendo as vari√°veis

Ap√≥s uma an√°lise inicial das tabelas geradas pelo `skimr`, selecionei algumas vari√°veis que seriam analisadas mais profundamente. A come√ßar pelas vari√°veis relativas a notas, cr√≠ticas e avalia√ß√µes dos jogos.

```{r, varReview}

ggplot(df_selected_gen, aes(metacritic_score)) +
  geom_histogram() +
  theme_minimal() +
  labs(title = "Histograma da vari√°vel Metacritic Score",
       x = "Score",
       y = "Contagem")
```

Pelo Histograma podemos ver que a vari√°vel *Metacritic Score* (renomeada para metacritic_score) n√£o √© muito interessante, seu preenchimento foi visto como completo pelo skim, por√©m quase em sua totalidade as notas s√£o "0", ou seja, n√£o temos uma nota definida para avaliar os jogos.

Outras vari√°veis de avalia√ß√£o como *Reviews*, *User Score*, e *Recommendations*, foram analisadas por√©m apresentaram pouco √∫teis, ou por terem um preenchimento muito baixo ou por envolverem outros tipos de dados (que n√£o fossem uma avalia√ß√£o direta).

##### Nova m√©trica de avalia√ß√µes

A √∫nica m√©trica que parece interessante de avalia√ß√£o dos jogos, √© a de avalia√ß√µes positivas e negativas (as vari√°veis *Positive* e *Negative*).

Para isso foi criado uma nova vari√°vel, que mede a taxa de avalia√ß√µes positivas e negativas de um jogo, chamada *overall_rate*.

```{r, var_overallRate}
df_selected_gen$overall <- df_selected_gen$positive*100/(df_selected_gen$positive + df_selected_gen$negative)

df_selected_gen$overall[1:100]
```

Analisando essa nova m√©trica, verificamos que possu√≠mos dados `NaN` e valores de 100, respectivamente, resultados de de divis√µes $0/0$ e de jogos sem avalia√ß√£o negativa. Os n√∫meros NaN ser√£o removidos, j√° que n√£o ser√£o √∫teis para avalia√ß√£o dos jogos, os n√∫meros 100 ser√£o investigados mais a fundo.

##### Filtrando dados inv√°lidos

```{r, NaN-100}

## Criando uma vari√°vel do tipo fator para n√∫mero de donos estimados
levels_owners <- c("0 - 0", "0 - 20000", "20000 - 50000", "50000 - 100000", 
                   "100000 - 200000", "200000 - 500000", "500000 - 1000000",
                   "1000000 - 2000000", "2000000 - 5000000", "5000000 - 10000000", 
                   "10000000 - 20000000", "20000000 - 50000000", "50000000 - 100000000",
                   "100000000 - 200000000")

df_selected_gen$estimated_owners <- as.factor(df_selected_gen$estimated_owners)
df_selected_gen$estimated_owners <- factor(df_selected_gen$estimated_owners, levels = levels_owners)

## Verificando dados que ser√£o considerados inv√°lidos
df_100 <- df_selected_gen |> 
  dplyr::filter(positive < 20 & (overall == 100)) |> 
  dplyr::select(name, publishers, categories, genres, release_date, estimated_owners, positive, negative, overall)

## Filtrando regras
df_selected_gen <- df_selected_gen |> 
  dplyr::filter(positive > 20 & 
                  ((as.integer(estimated_owners) > 2 & price > 0) | 
                     (as.integer(estimated_owners) > 3 & price == 0)) &
                  overall < 100)

# skimr::skim(df_selected_gen)
```

E ent√£o defini mais alguns filtros, de jogos que possivelmente seriam problem√°ticos. Estabeleci as regras:
  
  1.  O jogo precisa ter pelo menos 20 avalia√ß√µes positivas.

2.  O jogo precisa ter pelo menos uma avalia√ß√£o negativa (para que a avalia√ß√£o n√£o seja de 100%).

3.  O jogo precisa ter pelo menos 50 mil usu√°rios no caso de ser gratuito, e pelo menos 20 mil usu√°rios para jogos pagos.

##### Deduplica√ß√£o

Ap√≥s a an√°lise do novo banco de dados filtrado, descobri mais um problema que precisava ser tratado, dados duplicados. Verificando pelo nome dos jogos, encontrei dados duplicados, mas que possu√≠am IDs diferentes, avalia√ß√µes e √†s vezes pre√ßos diferentes. Investigando mais pelo pr√≥prio site da Steam e pelo site SteamDB ([SteamDB](https://steamdb.info)), conclu√≠ que se tratavam de dados referentes √† novas vers√µes (jogo do ano, vers√£o de luxo, etc), jogos que possu√≠am vers√µes diferentes (no caso dos Call of Dutys, vers√µes para o jogo campanha e para o jogo multiplayer, mini-expans√µes, pacotes de skins (apar√™ncias para armas e personagens), pacotes de itens pagos como benef√≠cios no jogos, etc. Portanto, decidi remover essas duplicatas, e usarei como base dados de n√∫mero de usu√°rios (o jogo base muito provavelmente vai ter mais usu√°rios) e n√∫mero de jogadores. 

```{r, dedup}
df_dupli <- df_selected_gen |> 
  janitor::get_dupes(name, developers)

df_selected_gen <- df_selected_gen |> 
  dplyr::arrange(name, desc(as.integer(estimated_owners)), desc(overall)) |> 
  dplyr::distinct(name, .keep_all = T)
```

Ent√£o a regra criada para este filtro respeitar√°, primeiro o n√∫mero de jogadores, o jogo que possuir mais jogadores permanecer√° na base, segundo, em caso de empate do primeiro, o jogo com melhor avalia√ß√£o.