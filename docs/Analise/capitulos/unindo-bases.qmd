```{r, header-unindo-bases}
########################################################################################## #
#'  Parte do arquivo de análise exploratória
#'  Arquivo focado na união das duas bases utilizadas
#' 
#'  Autor: Mikael Marin Coletto
#'  Data: 12/03/23
########################################################################################## #

## 0.1 - Bibliotecas e scripts fontes----

```

```{r, joinDBs}

## Jogos presentes na base 1 que não estão na base 3
df_antijoin_games <- dplyr::anti_join(df_selected_gen, df_games, by = "app_id") |> 
  dplyr::mutate(rating = 0, price_final = 0, price_original = 0, discount = 0, steam_deck = F, 
                db1 = T) |> 
  dplyr::select(app_id, title = name, date_release = release_date, win = windows, mac, linux, rating,
                positive_ratio = overall, user_reviews = user_score, price_final = price, price_original,
                discount, steam_deck, db1) 

df_games <- df_games |> 
  dplyr::mutate(db1 = F, date_release = lubridate::ymd(date_release))

df_all_games <- rbind(df_games, df_antijoin_games, fill = T)
```

Também foi analisado novamente as duplicatas que foram geradas, e novamente foi decidido mantê-lás, já que representavam, ou jogos que possuíam o mesmo nome, mas são jogos diferentes, ou são diferentes versões dos jogos (versão normal e versão game of the year ou um relançámento por exemplo).

##### Adicionando informações

Agora adicionaremos à base agrupada os dados referentes às informações do jogo, inicialmente adicionando através de outro arquivo presente nos arquivos da base 3.

```{r, addingInfo}
run_join <- F
if(run_join){
  library(jsonlite)
  out <- lapply(readLines("data-raw/steam-data/db-3/games_metadata.json"), fromJSON)
  
  ## Unindo o terceiro elemento da lista
  for(i in 1:length(out)){
    purrr::pluck(out, i, 3)<-paste0(purrr::pluck(out, i, 3), collapse = ",")
  }
  
  ## Transformando em um dataframe para unir à outra base
  df_metadata <- do.call(rbind.data.frame, out)
  
  ## Adicionando coluna de tags do df_metadata, e adicionando colunas de categoria, genero e tags extra do df anterior
  df_all_games <- dplyr::left_join(df_all_games, df_metadata, by = "app_id") |> 
    dplyr::select(-description) |> 
    dplyr::left_join(df_selected |> 
                       dplyr::select(app_id, categories, genres, tags) |> 
                       dplyr::rename(tags_extra = tags),
                     by = "app_id")
  
  ## Escrevendo nova base para não precisar rodar os joins e comparações todas as vezes
  if(!dir.exists("data-raw/steam-data/db-created")){
    dir.create("data-raw/steam-data/db-created")
  }
  data.table::fwrite(df_all_games, "data-raw/steam-data/db-created/db-reviews-join.csv")
  
}else{
  df_all_games <- data.table::fread(here::here("data-raw/steam-data/db-created/db-reviews-join.csv")
}

## Substituindo células em branco por NA no caso de estar lendo o csv
if(!run_join){
  df_all_games <- df_all_games |> 
    dplyr::mutate(categories = ifelse(categories == "", NA, categories),
                  genres = ifelse(genres == "", NA, genres),
                  tags = ifelse(tags == "", NA, tags),
                  tags_extra = ifelse(tags_extra == "", NA, tags_extra))
}

## Verificando quantos jogos não possuem categorias, gêneros ou tags/tags_extra definidos
nrow(df_all_games[is.na(categories), ])
nrow(df_all_games[is.na(genres), ])
nrow(df_all_games[is.na(tags) & is.na(tags_extra), ])
```
