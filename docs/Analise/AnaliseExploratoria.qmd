---
title: "Analise Exploratoria"
author: "Mikael M Coletto"
format: html
editor: source
execute: 
  cache: FALSE
---

```{r setup, include=FALSE}
knitr::opts_knit$set(root.dir = '/mnt/Netac-Dados/Projetos/R/steam-dashboard',
                     cache.lazy = FALSE)
path_quarto <- "../../"
source(paste0(path_quarto, "R/fct-auxiliares/fct_order_strings.R"))
```

# Análise dos dados da Steam

## Objetivo

A ideia desta análise é ilustrar os conhecimentos adquiridos em R, passando pelos pontos de análise exploratória, construção de um dashboard para visualização de dados e por fim trabalhar com modelos de predição para alguns possíveis problemas da indústria.

## Primeiro problema

Somos um estúdio de jogos e queremos analisar qual gênero/categoria de jogo tem mais sucesso na steam, mais público e melhores avaliações, também queremos analisar qual faixa de preço é mais interessante para o lançamento desse novo jogo.

### Primeiro passo - Análise exploratória

Inicialmente iremos fazer uma análise exploratória de algumas bases de dados e suas variáveis que podem ser interessantes para determinar sucesso de um jogo, a faixa de preço, a quantidade de vendas e relacionar essas questões aos gêneros e categorias. Foram feitas análises de três bases de dados, a primeira mais completa, e as duas seguintes mais focadas em reviews de usuários.

#### Base de dados - 1

```{r, child="docs/Analise/capitulos/analise-base-1.qmd"}
```

#### Base de dados - 2

```{r, child="docs/Analise/capitulos/analise-base-2.qmd"}
```

#### Base de dados - 3

```{r, child="docs/Analise/capitulos/analise-base-3.qmd"}
```

#### Diferenças entre base 1 e 3

```{r, child="docs/Analise/capitulos/dif-entre-bases.qmd"}
```

#### Unindo as bases

```{r, child="docs/Analise/capitulos/unindo-bases.qmd"}
```

### Analisando dados dos jogos

Agora que já uni as duas bases, e tenho uma quantidade mais razoável de jogos a serem analisados, precisarei definir qual será a forma de avaliar os estilos/gêneros/categorias dos jogos, por ser uma coluna presente em ambas as bases, a variável `tags` é uma ótima candidata, porém ela apresenta um número de possibilidades bastante grande e distinta, o que poderia ser prejudicial à análise. Já as outras variáveis `categories` e `genres` que são mais específicas, não estão presentes em aproximadamente 20% da base de dados. A análise será feita inicialmente nas três para posterior decisão de qual ou quais usar.

#### Categorias

```{r, categs-count}
df_all_games |> 
  dplyr::filter(!(is.na(categories)) & categories != "") |> 
  nrow()
```

Ou seja, temos aproximadamente 20% da base de dados sem nenhuma informação de categorias, a variável poderia ser utilizada, porém com algumas ressalvas.

#### Gêneros

```{r, genres-count}
df_all_games |> 
  dplyr::filter(!(is.na(genres)) & genres != "") |> 
  nrow()
```

Novamente, cerca de 20% da base sem informações de gênero.

#### Categorias e Gênero

```{r, categs-genres-count}
df_all_games |> 
  dplyr::filter(!(is.na(categories)) & categories != "") |> 
  dplyr::filter(!(is.na(genres)) & genres != "") |> 
  nrow()
```

E, para efeito de comparação, podemos ver que os valores sem categorias e gênero são as mesmas observações, o que faz bastante sentido já que foram unidas e uma das duas bases não possuía essas colunas.

#### Tags

```{r, tags-count}
df_all_games |> 
  dplyr::filter(!(is.na(tags)) & tags != "" ||
                  (is.na(tags_extra)) & tags_extra != "") |> 
  nrow()
```

Já no caso das tags, temos todas as observações com tags ou tags_extra (o que também faz sentido, já que unimos duas bases diferentes e uma delas possuia a coluna tags e a outra tags_extra).

Portanto, faremos uma análise mais aprofundada para gerar uma única coluna que possa ser analisada.

```{r, child="docs/Analise/capitulos/tags.qmd"}
```

#### Investigando preços

Vamos agora nos debruçar sobre as faixas de preços e em seguida faremos um cruzamento dos dados de preços e tags.

```{r, child="docs/Analise/capitulos/price.qmd"}
```

#### Investigando jogos bem avaliados

```{r, child="docs/Analise/capitulos/well-reviewed.qmd"}
```


```{r}
## Variáveis (independentes) que podem ser relevantes para prever o sucesso (medido por positive_ratio)
## windows (binária, dummie), linux (binária, dummie), mac (binária, dummie),
## price_final (numérica, discreta), steam_deck (binária, dummie),
## tags_all (categórica, precisa ser transformada em dummies)

## Variável target (dependente) positive_ratio, numérica
```


```{r, treinando-flight-data}

# df_all_games <- data.table::fread(here::here("data-raw/created-tables/db-all-games-tags-all.csv"))

library(tidymodels)      # for the recipes package, along with the rest of tidymodels

# Helper packages
library(nycflights13)    # for flight data
library(skimr)           # for variable summaries

flight_data <- 
  flights %>% 
  mutate(
    # Convert the arrival delay to a factor
    arr_delay = ifelse(arr_delay >= 30, "late", "on_time"),
    arr_delay = factor(arr_delay),
    # We will use the date (not date-time) in the recipe below
    date = lubridate::as_date(time_hour)
  ) %>% 
  # Include the weather data
  inner_join(weather, by = c("origin", "time_hour")) %>% 
  # Only retain the specific columns we will use
  select(dep_time, flight, origin, dest, air_time, distance, 
         carrier, date, arr_delay, time_hour) %>% 
  # Exclude missing data
  na.omit() %>% 
  # For creating models, it is better to have qualitative columns
  # encoded as factors (instead of character strings)
  mutate_if(is.character, as.factor)

flight_data %>% 
  count(arr_delay) %>% 
  mutate(prop = n/sum(n))


# Fix the random numbers by setting the seed 
# This enables the analysis to be reproducible when random numbers are used 
set.seed(222)
# Put 3/4 of the data into the training set 
data_split <- initial_split(flight_data, prop = 3/4)

# Create data frames for the two sets:
train_data <- training(data_split)
test_data  <- testing(data_split)

flights_rec <- 
  recipe(arr_delay ~ ., data = train_data) %>% 
  update_role(flight, time_hour, new_role = "ID") 

summary(flights_rec)

flights_rec <- 
  recipe(arr_delay ~ ., data = train_data) %>% 
  update_role(flight, time_hour, new_role = "ID") %>% 
  step_date(date, features = c("dow", "month")) %>%               
  step_holiday(date, 
               holidays = timeDate::listHolidays("US"), 
               keep_original_cols = FALSE)

flights_rec <- 
  recipe(arr_delay ~ ., data = train_data) %>% 
  update_role(flight, time_hour, new_role = "ID") %>% 
  step_date(date, features = c("dow", "month")) %>%               
  step_holiday(date, 
               holidays = timeDate::listHolidays("US"), 
               keep_original_cols = FALSE) %>% 
  step_dummy(all_nominal_predictors())

df_games_sample <- df_all_games |> 
  dplyr::slice_sample(n = 1000)

n_top <- 50

# separate the categories into separate rows
df_games_sample_split <- tidyr::separate_rows(df_games_sample, tags_all, sep = ",") |> 
  dplyr::mutate(tags_all = ifelse(tags_all == "", "unknown", tags_all))

df_games_sample_split <- func_filter_top(df_games_sample_split, n_top, debug = T)

# convert category column into dummy variables
dummies <- tidyr::pivot_wider(df_games_sample_split, id_cols = app_id, names_from = tags_all, values_from = tags_all, values_fill = "0") |> 
  dplyr::mutate(dplyr::across(2:(n_top+1), ~ dplyr::if_else(.x == "0", .x, "1")))


# create sample data with multiple categories per row
data <- data.frame(id = 1:4, categories = c("A, B, C", "B, C", "A, C", "B"))

# separate the categories into separate rows
data_split <- separate_rows(data, categories, sep = ", ")

# convert category column into dummy variables
dummies <- pivot_wider(data_split, id_cols = id, names_from = categories, values_from = categories, values_fill = " ")


```


#### Resposta do chatGPT

Para analisar a melhor faixa de preço para lançar um produto com base nas informações de preços de outros competidores, você pode seguir os seguintes passos:

Coletar informações sobre os preços dos produtos concorrentes: colete informações sobre os preços dos produtos concorrentes na mesma categoria ou segmento de mercado do seu produto. Você pode usar ferramentas como pesquisas online, visitas a lojas, análise de dados de mercado, entre outras.

Analisar a faixa de preços dos produtos concorrentes: depois de coletar as informações sobre os preços dos produtos concorrentes, analise a faixa de preços. Você pode agrupar os preços em categorias, como baixo, médio e alto, ou usar técnicas estatísticas, como análise de quartis ou médias, para identificar a faixa de preços.

Comparar os preços com as características dos produtos: avalie as características dos produtos concorrentes que estão na mesma faixa de preços. Analise aspectos como qualidade, design, funcionalidades, marca, reputação, entre outros.

Definir uma faixa de preços para o seu produto: com base nas informações coletadas e na análise dos preços e características dos produtos concorrentes, defina uma faixa de preços para o seu produto. Lembre-se de considerar fatores como os custos de produção, a margem de lucro desejada, a percepção de valor pelos clientes, entre outros.

Testar a faixa de preços: depois de definir a faixa de preços, teste-a com potenciais clientes. Você pode realizar pesquisas de mercado, criar ofertas promocionais ou realizar testes de preços em pequena escala para avaliar a receptividade dos clientes e fazer ajustes se necessário.

Monitorar e ajustar os preços: monitore continuamente os preços dos produtos concorrentes e a demanda pelo seu produto e faça ajustes na faixa de preços conforme necessário para manter uma posição competitiva no mercado.

Lembre-se de que a análise de preços dos concorrentes é apenas uma das informações que você deve considerar ao definir a faixa de preços para o seu produto. Outros fatores, como o posicionamento da marca, o público-alvo, a estratégia de marketing e os objetivos de negócios também devem ser levados em consideração.